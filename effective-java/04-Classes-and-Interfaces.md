# 클래스와 인터페이스

**클래스와 인터페이스**에서는 추상화의 기본 단위인 클래스와 인터페이스를 쓰기 편하고, 견고하며, 유연하게 만드는 방법을 안내합니다.

## 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라

* 컴포넌트의 설계에 대한 수준은 클래스 내부 데이터와 구현 정보를 외부로부터 얼마나 잘 숨겼느냐에 결정됨
* 즉, 잘 설계된 컴포넌트는 내부를 잘숨겨 구현과 API를 깔끔히 분리됨
* 이는 **캡슐화**라고 하는 소프트웨어 설계의 근간이 되는 원리

### 자바에서 캡슐화시 주의점

* 모든 클래스와 맴버의 접근성을 가능한 좁혀야함
* public 클래스의 인스턴스의 맴버는 되도록 public이 아니어야 함
* 클래스의 맴버로 public static final 배열이 존재하거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안됨

## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

* public 클래스의 맴버를 public하면 캡슐화의 이점을 제공하지 못함
* 맴버를 private로 정의하고 접근자(getter) 메서드를 제공해야함
* package-private 클래스 또는 private 중첩클래스라면 맴버가 public이어도 상관없음

## 아이템 17. 변경 가능성을 최소화하라

* 불변 클래스란 인스턴스 내부의 맴버를 수정할 수 없는 클래스를 의미함
* 자바에는 여러가지의 불변 클래스가 존재
  * String
  * 기본타입의 박싱된 클래스
  * BigInteger, BigDecimal
* 클래스를 불변으로 만들려면 다음과 같은 규칙을 따르면됨
  * 객체의 상태를 변경하는 메서드를 제공하지 않음
  * 상속을 막음 (final선언 등)
  * 모든 필드를 final로 선언
  * 모든 필드를 private로 선언
    * public final은 다음 배포에서 수정할 수 없다는 단점이 존재
  * 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 함
    * 생성자, 접근자, readObject메서드에서 모두 방어적 복사를 수행해야함
* 불변 객체는 근본적으로 스레드에 안전하며 따로 동기화 할 필요가 없음
* 객체를 만들때 구성요소로 불변 객체를 사용하면 이점이 많음
  * 구조가 아무리 복잡하더라도 불변식을 유지하기 훨씬 수월하기 때문
* 불변 객체는 그 자체로 실패 원자성을 제공
  * 상태가 절대 변하지 않기 때문에
* 불변 클래스에도 단점은 존재
  * 값이 다르면 반드시 독립된 객체로 만들어야한다는 점
* 클래스는 꼭 필요한 경우가 아니라면 불변이어야 함
* 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소화해야함
  * 합당한 이유가 없다면 모든 필드는 private final이어야 함

## 아이템 18. 상속보다는 컴포지션을 사용하라

* 상속은 코드를 재사용하는 강력한 수단이지만, 잘못 사용하면 오류를 내기 쉬운 소프트웨어를 만들게 됨
* 다른 패키지의 구체 클래스를 상속하는일은 위험함
* 메서드 호출과 달리 상속은 캡슐화를 깨뜨림

## 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

## 아이템 20. 추상 클래스보다는 인터페이스를 우선하라

## 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

## 아이템 22. 인터페이스는 타입을 정의하는 용도로만 사용하라

* 인터페이스는 자신을 구현하는 클래스를 참조하는 타입역할을 함
* 참조역할 아닌 인터페이스 내부에 상수를 구현해서 사용하는 것은 안티패턴임

```java
public interface MathConstants {
    static final double PI = 3.14;
}
```

* 클래스 내부에서 사용할 상수를 인터페이스에 정의하는 것은 내부 구현을 외부로 노출하는 행위, 사용자에게 의미도 없고 혼란만 줌
* 해당 인터페이스를 구현한 클래스나 구현한 클래스의 하위 클래스의 이름공간이 인터페이스에 정의된 상수로 오염됨

## 아이템 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라

* 다음과 같이 하나의 클래스에 현재 상태표현을 태그로 알려주는 클래스보다는 계층구조를 사용해야함
* 다음 클래스는 Shape 맴버로 현재 상태를 의미

```java
class Figure {
  enum Shape { RECTANGE, CIRCLE} ;
  double length;
  double width;

  double radius;
}
```

### 태그 기반 표현의 단점

* 내부에 열거형 선언, 태그 필드, 공통로직에서 swtich 등 쓸데없는 코드가 많아짐
* 한가지 타입에 포함될 것이지만 두가지 타입을 처리하는 로직이 함께 존재해 메모리 사용랴잉 많아짐
* 사용하지 않을 타입에서 사용할 final 필드도 같이 초기화 해야함
* 즉 클래스가 장황해지고 오류를 내기 쉽고 비효율적임

### 클래스 계층구조를 이용

* 위 클래스를 계층구조로 나타내면 다음과 같음

```java
abstract class Figure {...}

class Circle extends Figure {
  double radius;
  ...
}

class Rectangle extends Figure {
  double length;
  double width;
  ...
}
```

## 아이템 24. 멤버 클래스는 되도록 static으로 만들라

* 

## 아이템 25. 톱레벨 클래스는 한 파일에 하나만 담으라

* 하나의 소스 파일에는 하나의 톱 레벨 클래스(또는 톱 레벨 인터페이스)만 작성해야함
* 톱 레벨 클래스란 맴버 클래스가 아닌 클래스

## References

* [이펙티브 자바 3/e](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788966262281&orderClick=LEA&Kc=)