# 가비지 수집 기초

* 자바 플랫폼이 처음 출시됐을 때 GC는 상당한 반감을 샀음
  * 언어 수준에서 의도적으로 수집기 작성을 제어하지 못하는 이유도 포함
* 그러나 세월이 지나면서 유저가 제어할 수 없는, 강제적인 초기 GC는 그 정당성이 충분히 입증되
* 자바 가비지 수집의 요체는 시스템에 있는 모든 객체의 수명을 정확히 몰라도 런타임이 대신 객체를 추적하여 쓸모없는 객체를 알아서 제거하는 것
* 모든 가비지 수집 구현체는 다음의 두 가지 원칙을 준수해야함
  * 알고리즘은 반드시 모든 가비지를 수집해야함
  * 살아 있는 객체는 절대로 수집해선 안됨
* 프로그래머마 저수준 세부를 일일이 신경쓰지 않는 대가로 저수준 제어권을 포기한다는 사랑이 바로 자바 관리 방식의 핵심
  * 제임스 고슬링이 블루칼라 언어라고 말한 특징이 잘 드러나는 대목

## 1. 마크 앤 스위프

* 마크 앤 스위프 알고리즘, 즉 표시하고 쓸어담기로 동작
* 여기서는 GC 알고리즘을 단순화하여 설명(실제 운영계 JVM의 GC와는 다름)
* 전체적인 GC알고리즘
  1. 할당 리스트를 순회, 마크 비트를 지움
  2. GC 루트부터 살아 있는 객체를 찾음
  3. 찾은 객체마다 마크 비트를 세팅
  4. 할당 리스트를 순회하며 마크비트가 세팅되지 않는 객체를 찾음
    1. 힙에서 메모리를 회수해 프리 리스트로 되돌림
    2. 할랑 디스트에서 객체를 삭제
* 살아있는 객체는 깊이 우선 탐색으로 찾음
* 이렇게 생성된 객체 그래프를 라이브 객체 그래프(live object graph)라고 함
* 접근 가능한 전이 패쇄(transitive closure of reachable objects)라고도 함

* 가비지 수집 용어
  * STW: GC 사이클이 발생하는 동안 모든 스레드가 중단됨
  * 동시: GC 스레드는 애플리케이션 스레드와 동시에 실행될 수 있음
  * 병렬: 여러 스레드를 동원해 가비지 수집
  * 정확: 정확한 GC 스킴은 전체 가비지를 한방에 수집할 수 있게 힙 상태에 관한 충분한 타임정보를 가지고 있음
  * 보수: 보수적인 스킴은 정확한 스킴 정보가 없음
  * 이동: 이동 수집기에서 객체는 메모리 여기저기로 이동할 수 있음
  * 압착: GC 사이클 마지막에는 연속된 단일 영역으로 배열됨, 이는 메모리 단편화를 방지
  * 방출: 수집 사이클 마지막에 할당된 영역을 완전히 비우고 살아남은 객체는 다른 메모리 영역으로 이동시킴

## 2. 핫스팟 런타임 개요

* GC를 이해할려면 핫스팟 내부도 어느정도는 알아야함
* 자바에서는 두값만 사용
  * 기본형
  * 객체형
* 자바는 C++와 달리 역참조하는 일반적인 매커니즘이 없고, 오직 오프셋 연산자만으로 필드에 엑세스하거나 객체 레퍼런스의 메서드를 호출할 수 있음
* 


## 3. 할당과 수명

* 자바 애플리케시이션에서 가비지 수집이 일어나는 주된 원인은 다음 두 가지
  * 할당률
  * 객체 수명

## 4. 핫스팟과 가비지 수집

* 
* 

## 5. 병렬 수집기

* 
* 

## 6. 할당과 역할

* 
* 

## References

* [자바 최적화](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791162241776&orderClick=LAG&Kc=)