# 영속성 어댑터 구현하기

* 1장에서 계층형 아키텍처는 결국 모든것이 영속성 계층에 의존되어 '데이터베이스 주도 설계'가 된다고 이야기함
* 이번 장에서 이러한 의존성을 역전시키키위한 영속성 계층을 애플리케이션 계층의 플러그인으로 만드는 방법을 살펴봄

## 의존성 역전

![]()

* 애플리케이션 서비스에서 영속성 기능을 사용하기 위해 포트 인터페이스를 호출
* 포트는 실제 영속성 작업을 수행하고 데이터베이스와 통신하는 영속성 어댑터 클래스에 의해 구현
  * 영속성 어댑터 클래스는 아웃고잉 어댑터, 애플리케이션에 의해 호출될뿐 호출하지는 않음
* 의존성이 애플리케이션에서 영속성 어댑터로 향하기 때문에 코어에 영향을 미치지 않으면서 영속성 코드를 변경시킬 수 있음
  * 영속성 라이브러리 변경등 (JDBC -> JPA)

## 영속성 어댑터의 책임

* 영속성 어댑터가 하는일
  1. 입력을 받음
  2. 입력을 데이터베이스 포맷으로 매핑
  3. 입력을 데이터베이스 보냄
  4. 데이터베이스 출력을 애플리케이션 포맷으로 매핑
  5. 출력 반환


## 포트 인터페이스 나누기

* 서비스를 구현하면서 생기는 의문은 데이터베이스 연산을 정의하는 포트 인터페이스를 어떻게 나눌것인가임
* 인터페이스 분리 원칙(Interface Segregation Principle, ISP)는 이에 대한 답을 제시함
  * 이 원칙은 클라이언트가 오로지 자신이 필요로 하는 메서드만 알면 되도록 인터페이스로 분리해야한다고 설명함 


![]()

![]()

* 각 서비스는 실제로 필요한 메서드에만 의존
* 포트 이름이 포트의 역할을 잘 표현함
* 물론 모든 상황에 포트 하나당 하나의 메서드 적용이 적합한것은 아님
  <!-- * 응집성이 높고 함께 사용될 때가 많으면 하나의 인터페이스로  -->

## 영속성 어댑터 나누기

* 영속성 어댑터를 하나로 구성할 필요는 없음
* 도메인 클래스(DDD의 애그리거트) 하나당 하나의 영속성 어댑터를 구현할 수 있음
  * 이렇게 하면 영속성 어댑터들은 각 영속성 기능을 이용하는 도메인 경계를 따라 자동으로 나뉨
  * 여러개의 바운디드 컨텍스트(bounded context)의 영속성 요구사항을 분리하기 위한 좋은 토대가 됨

## 스프링 데이터 JPA 예제

## 데이터베이스 트랜잭션은 어떻게 해야 할까?

* 트랜젝션은 하나의 유스케이스에대 일어나는 모든 쓰기 작업에 걸쳐 있어야함
* 영속성 어댑터는 어떤 데이터베이스 연산이 같이 호출될지 알지 못하기 때문에 트랜젝션을 언제 열고 닫을지 알 수 없음
* 자바와 스프링에서는 `@Transactional` 애너테이션을 서비스 클래스에 붙여서 트랜젝션 처리가능
* 만약 서비스가 `@Transactional` 애너테이션으로 오염되지 않고 깔끔하게 유지되길 원한다면 AspectJ같은 도구를 사용해 관점 지향 프로그래밍(aspect-oriented programming)으로 트랜잭션 경계를 위빙(weaving)할 수 있음

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
