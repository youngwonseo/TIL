# 유스케이스 구현하기

* 앞에서 논의한 육각형 아키텍처 스타일에서의 유스케이스를 살펴봄
* 육각형 아키텍처는 도메인 중심의 아키텍처에 적합하기 때문에 도메인 엔티티를 만드는 것으로 시작, 이 후 도메인 엔티티를 중심으로 유스케이스를 구현

## 도메인 모델 구현하기

## 유스케이스 둘러보기

* 일반적으로 유스케이스는 다음과 같은 단계를 따름
  1. 입력을 받는다
  2. 비즈니스 규칙을 검증한다
  3. 모델 상태를 조작한다
  4. 출력을 반환한다
* 유스케이스는 인커밍 어댑터로부터 입력을 받음
  * 유효성 검증은 도메인 로직과는 분리도어야 함으로 여기서 다루지 않음
* 

## 입력 유효성 검증

* 입력 유효성 검증은 유스케이스 클래스의 책임이 아님, 애플리케이션 계층의 책임
* 호출하는 어댑터가 유스케이스에 입력을 전달하는 경우 문제점
* 애플리케이션에서 유효성을 검증해야하는 이유는, 그렇지 않을 경우 애플리케이션 코어의 바깥쪽으로부터 유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수 있기 때문

* 자바에는 Bean Validation API가 존재

## 생성자의 힘

* 앞에서 살펴본 SendMoneyCommand는 생성자에 많은 책임(유효성 검증)을 지우고 있음
* 불변 클래스이기 때문에 생성자를 통해 맴버들을 초기화함
* 만약 SendMoneyCommand의 필드가 많아지면 빌더 패턴을 고려할 수 있음
* 그러나 빌더 패턴은 빌더와 생성자에 새로운 필드를 추가하고, 빌더를 호출하는 코드에 새로운 필드를 추가해야함
  * 필더를 호출하는 코드에 새로운 필드추가가 누락되어도 컴파일러는 알려주지 못함
* 빌더 대신 생성자를 직접 사용하면 새로운 필드를 추가하거나 삭제할 때마다 컴파일러 에러를 확인할 수 있어서 변경사항이 누락되지 않음
* 최근 IDE는 많은 파라미터를 가지는 생성자(또는 함수)의 파라미터 명을 명시해줌

## 유스케이스마다 다른 입력 모델

* 각기 다른 유스케이스에서 동일한 입력 모델을 사용하고 싶을 수 있음
* 입력 모델이 거의 비슷한경우가 각 상황에 필요하지 않은 필드를 null로 처리하고 공통으로 사용할 수 있음
* 그러나 불변 커맨드 객체의 필드를 위와 같이 null(유효한 상황을)로 받아들이는 것은 그 자체로 코드 냄새(code smell)
* 더 문제가 되는것은 입력 유효성을 어떻게 검증하는가임
* 커맨드 객체 생성시점이 아닌 유스케이스에서 유효성 검증을 할 수 있으나, 이는 신성한 비즈니스 코드를 입력 유효성 검증과 관련된 관심사로 오염시킴
  * 사용하지 않는 필드에 null이 아닌값이 들어오면 혼란이 가중됨
* 각 유스케이스의 전용 입력 모델은 유스케이스를 명확하게 만들고 불필요한 결합도를 제거

## 비즈니스 규칙 검증하기

* 입력 유효성 검증은 유스케이스 로직의 일부가 아니지만 비스니즈 규칙 검증은 유스케이스 로직의 일부
* 비즈니스 규칙은 애플리케이션의 핵심이기 때문에 적절하게 다루어야함
* 입력 유효성 검증과 비즈니스 규칙의 차이는 비즈니스 규칙은 도메인 모델의 현재 상태에 접근해야한다는 것
  * 입력 유효성 검증은 구문상(syntactical)의 유효성 검증
  * 비즈니스 규칙 검증은 의미적인(semantical) 유효성 검증

## 풍부한 도메인 모델 vs. 빈약한 도메인 모델

* 

## 유스케이스마다 다른 출력 모델

* 입력과 비슷하게 출력도 각 유스케이스에 맞게 구체적일수록 좋음
* 호출자에게 꼭 필요한 정보만 가지고 있어야함

## 일기 전용 유스케이스는 어떨까?

* 읽기 전용 유스케이스는 애플리케이션 관점에서는 간단한 데이터 쿼리임
* 그렇기 때문에 유스케이스와 구분되는 쿼리로 표현가능
* 이런 방식은 CQS(Command-Query Separation)나 CQRS(Command-Query Responsibility Segregation) 같은 개념과 아주 잘 맞음
  * 데이터 조회 작업과 데이터 업데이트 작업의 책임을 분리시키는 패턴

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도음이 될까?

* 