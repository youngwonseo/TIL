# 의식적으로 지름길 사용하기

* 

## 왜 지름길은 깨진 창문 같을까?

* [](https://namu.wiki/w/%EA%B9%A8%EC%A7%84%20%EC%9C%A0%EB%A6%AC%EC%B0%BD%20%EC%9D%B4%EB%A1%A0)을 책의 저자는 다음과 같이 표현

> 어떤 것이 멈춘 것처럼 보이고, 망가져 보이고, 혹은 관리되지 않는다고 여겨지면 인간의 뇌는 이를 더 멈추고, 더 망가뜨려도 된다고 생각하게 된다

* 이를 코드 작업에 절용될때 의미는 다음과 같아짐
  * 품질이 떨어진 코드에서 작업할때 더 낮은 품질의 코드를 추가하기가 쉬움
  * 코딩 규칙을 많이 어긴 코드에서 작업할 때 또 다른 규칙을 어기기도 쉬움
  * 지름길을 많이 사용한 코드에서 작업할 때 또 다른 지름길을 추가하기도 쉬움
* 이 모든 것을 고려하면 레거시라고 불리는 많은 코드의 품질이 시간이 가면서 심하게 낮아졌다는 것은 그리 놀라운 일이 아님

## 깨끗한 상태로 시작할 책임

* 코드를 짜는 것은 깨진 창문 심리에 무의식적으로 영향을 받음
* 그래서 가능한 한 지름길을 쓰지 않고 기술 부채를 지지 않은 채로 프로젝트를 깨끗하게 시작하는 것이 중요
  * 지름길이 스며드는 순간 더 많은 지름길을 끌어들이기 때문
* 소프트웨어 프로젝트는 큰 비용이 들고 장기적인 노력을 필요로 하기 때문에 깨진창문을 막는 것이 개발자들의 아주 막대한 책임임
* 프로젝트를 인계받는 입장에서는 깨진 창문을 만들어 내기가 더 쉬움
* 그러나 때로는 지름길을 취하는 것이 더 실용적일 때도 있음
  * 전체에서 그리 중요하지 않은 부분
  * 프토로타이핑 작업중
  * 경제적인 이유
* 이러한 의도적인 지름길에 대해서는 세심하게 기록이 잘 되어야함
* 마이클 나이가드가 제안한 아키텍처 결정 기록(Architecture Decision Records, ADRs)의 형태도 좋음
* 팀원 모두가 이 문서에 대해 인지하고 있다면 지름길이 합리적인 이유에 의해 의도적으로 추가됐다는 사실을 인지하고 있기 때문에 깨진 창문 이론의 영향을 줄일 수 있음

## 유스케이스 간 모델 공유하기

* 4장에서 유스케이스마다 다른 입출력 모델을 가져야 한다고 이야기함
* 유스케이스 간 모델을 공유하면 공유하고 있는 모델이 변경되면 여러 유스케이스에 모두 영향을 미침
  * 단일 책임 원칙에서 '변경할 이유'를 공유하는 것
* 유스케이스 간 모델을 공유하는 것은 유스케이스들이 기능적으로 묶여있을때 유효
  * 즉 특정 요구사항을 공유할때
  * 특정 세부 사항을 변경할 경우 실제로 두 유스케이스 모두에 영향을 주고 싶은 것
* 두 유스케이스가 독립적은로 진화해야한다면 입출력 모델을 공유하는 것은 지름길에 해당
  * 처음에는 똑같더라도 분리해서 시작해야함

## 도메인 엔티티를 입출력 모델로 사용하기

* 엔티티를 인커밍 포트의 입출력으로 사용하고 싶다는 생각이 들지도 모름
* 인커밍포트는 도메인 엔티티의 의존성을 가짐
  * 엔티티가 변경할 이유가 존재
  * 엔티티는 인커밍포트에 의존성이 없는데(반대방향이기 때문에) 변경할 이유는 무엇일까?
* 엔티티에 존재하지 않는 정보가 유스케이스에서 필요하다고 가정
* 실제 이 정보는 다른 엔티티(다른 도메인 또는 다른 바운디드 컨텍스트)에 저장되어야함, 그럼에도 유스케이스에서 사용할 수 있기 때문에 해당 엔티티에 필드를 추가 하고 싶다는 생각이 듬
* 간단한 생성이나 업데이트 유스케이스에서는 유스케이스 인터페이스에 도메인 엔티티가 있는것이 괜찮아 보일 수 있음
* 그러나 단순히 업데이하는 수준이 아니라 복작합 도메인 로직을 구현해야한다면(도메인 로직의 일부를 풍부한 도메인 엔티티로 위임) 유스케이스를 위한 전용 입출력 모델을 만들어야함
  * 유스케이스 변경이 도메인 엔티티까지 영향을 주지 안헥 하기 위해
* 이 지름길이 위험한 이유는 많은 유스케이스가 간단한 생성 또는 업데이트로 시작해 시간이 지나면서 복잡한 도메인 로직 괴물이 되어가기 때문
* 이는 MVP로 시작해 점점 복잡도를 높여가는 애자일 환경에서 특히 그럼

## 인커밍 포트 건너뛰기

* 아웃고잉 포트는 애플리케이션 계층과 아웃고잉 어댑터 사이의 의존성 역전을 위한 필수 요소인 반면 인커밍 포트는 의존성 역전에 필수 적인 요소는 아님
* 인커밍 어댑터가 인커밍 포트 없이 애플리케이션 서비스에 직접 접근하도록 할 수 있음
* 이런 경우 하나의 추상화 계층이 없어져 괜찮게 느껴질 수 있음
* 하지만 인커밍 포트는 애플리케이션 중심에 접근하는 진입점을 정의
* 인커밍 포트를 유지해야하는 또 다른 이유는 아키텍처를 쉽게 갈제할 수 있기 때문

## 애플리케이션 서비스 건너뛰기

* 애플리케이션 서비스없이 아웃고잉 어댑터가 직접 인커밍 포트를 구현할 수도 있음
* 하지만 이 방법은 인커밍 어댑터과 아웃고잉 어댑터 사이에 모델을 공유해야함
* 앞에서 이야기한 모데일 모델을 입력 모델로 사용하는 케이스가 됨
* 애플리케이션 코어에 유스케이스라고 할 만한 것이 없어짐
  * 시간이 지남에 따라 유스케이스가 점점 복잡해지면 도메인 로직을 아웃고잉 어댑터에 추가하고 싶은 생각이 듬
  * 이러면 도메인 로직이 흩어져서 도메인 로직을 유지보수하기가 어려워짐

## 유지보수 가능한 소프트우어를 만드는데 어떻게 도움이 될까?

* 