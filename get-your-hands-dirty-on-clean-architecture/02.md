# 의존성 역전하기

* 여기서는 단일 책임 원칙(Single Responsibility Principle, SRP)와 의존성 역전 원칙(Dependency Inversion Principle, DIP)에 대해서 알아봄
  * 이 원칙들의 자세한 내용은 로버트 C 마틴의 클린 아키텍처나 위키피티아를 참조

## 단일 책임 원칙

하나의 컴포넌트는 오로지 한 가지 일만 해야하고, 그것을 올바르게 수행해야한다.

* 이는 단일 책임을 가장 직관적으로 해석한 것임
* 이보다 더 적합한 정의는 다음과 같음

컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다

* '책임'은 '오로지 한 가지 일만 하는 것'보다는 '변경할 이유'로 해석해야함
* 오직 변경할 이유가 한 가지라면 컴포넌트는 딱 한가지 일만 하게됨
  * 더 중요한것은 변경할 이유가 한가지라는 것 자체
* 이것이 아키텍처에서는 어떤 의미일까?
  * 컴포넌트를 변경할 이우가 딱 한가지라면 우리가 **어떤 다른 이유**로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경쓸 필요가 없음
* 안타깝게도 변경할 이유라는 것은 컴포넌트 간의 의존성을 통해 너무도 쉽게 전파됨

[그림]

## 부수효과에 관한 이야기

* 10년 된 코드를 받아서 진행하는 프로젝트를 경험
* 예상했던 대로 코드를 이해하기 어려웠지만, 분석하고 테스트코드를 추가하고 리펙토링을 수행
* 더 나은 방법, 더 적은 비용을 제시했지만 클라이언트는 이와 다르게 이상한 이전 방식을 요구
* 이유는 이전 개발팀에서 해당 컴포넌트를 변경했을때 예상하지 못한 사이트 이펙트를 발생기켰기 때뮨

## 의존성 역전 원칙

* 계층형 아키텍처에서는 계층 간 의존성은 항상 다음 계층인 아래 방향을 가리킴
* 단일 책임 원칙을 고수준에서 적용할때 상위 계층들이 하위 계층들에 비해 변경할 이유가 더 많다는 것을 알 수 있음
  * 영속성 계층을 변경할 때마다 도메인 계층의 변경이 발생할 수 있음
  * 영속성 계층을 변경한다고 해서 도메인 계층까지는 바꾸고 싶지 않음, 이러한 의존성을 어떻게 제거할 수 있을까?
* 의존성 역전 원칙이 답을 알려줌
  * 단일 책임 원칙과 달리 이름 그대로를 의미

코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다

* 의존성의 양쪽 코드를 모두 제어할 수 있는 경우만 의존성 역전이 가능
  * 서드파티 라이브러리에 있는 의존성은 제어할 수 없음
* 도메인 코드와 영속성 코드 간의 의존성을 역전시켜서 영속성 코드가 도메인 코드에 의존하고 도메인 코드를 변경할 이유의 개수를 줄여보자

[그림]



## 클린 아키텍처

## 육각형 아키텍처(헥사고날 아키텍처)

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?