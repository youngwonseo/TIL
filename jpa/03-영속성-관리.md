# 영속성 관리

* JPA가 제공하는 기능은 크게 다음과 같이 나눌수 있음
  * 엔티티와 테이블을 매칭하는 설계부분
  * 매핑한 엔티티를 실제 사용하는 부분
* 이장에서는 매핑한 엔티티를 엔티티 매니저(EntityManage)를 통해 어떻게 사용하는지 알아봄
* 엔티티 매니저는 엔티티 저장, 수정, 삭제, 조회 등의 엔티티관련된 모든 일을 처리

## 1. 엔티티 매니저 팩토리와 엔티티 매니저

* 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전함
* 때문에 다른 스레드간에 공유해도 되지만 멘티티 매니저는 여러 스레드간 동시에 접근하면 동시성 문제가 발생

## 2. 영속성 컨텍스트란?

* JPA를 이해하는데 가장 중요한 용어는 영속성 컨텍스트(Persistence context)임

```

```

* 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장
* 영속선 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어짐
* 엔티티 매니저를 통해서 영속성 컨텍스트에 접근 및 관리

## 3. 엔티티의 생명주기

* 엔티티의 4가지 상태
  * 비영속(new/transient): 영속성 컨텍스트와 전혀 관계가 없는 상태
  * 영속(managed): 영속성 컨텍스트에 저장된 상태
  * 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
  * 삭제(removed): 삭제된 상태

### 비영속

* 엔티티 객체를 생성 했을때

### 영속

* 엔티티 매니저를 통해서 영속성 컨테스트에 저장한 상태 (em.persist)

### 준영속

* 영속성 컨텍스트가 관리하던 영속상태의 엔티티를 영속성 컨텍스르가 관리하지 않으면 준영속 상태가됨 (em.detach(), em.close(), em.clear())

### 삭제

* 삭제를 호출한후 상태(em.remove(member))

## 4. 영속성 컨텍스트의 특징

* 엔티티의 식별자값을 가짐
* 영속성 컨텍스트에 엔티티를 저장하면 트랜잭션이 커밋이 발생하는 순간 데이터베이스에 반영함, 이를 flush라 함
* 영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 존재
  * 1차 캐시
  * 동일성 보장
  * 트랜잭션을 지원하는 쓰기 지연
  * 변경 감지
  * 지연 로딩

### 엔티티 조회

### 엔티티 등록

### 엔티티 수정

### 엔티티 삭제

## 5. 플러시

* 플러시(flush)는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는것
* 플러시를 실행하면 다음과 같은 일이 발생
  1. 변경 감지가 동작
    * 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교
    * 수정된 엔티티를 찾고 해당 쿼리를 만들어 쓰기 지연 SQL저장소에 등록
  2. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스 전송
* 플러시를 발생하는 3가지 방법
  * em.flush() 호출
  * 트랜잭션 커밋 시 플러시가 자동 호출
  * JPQL 쿼리 실행 시 플러시가 자동 호출

* 다음과 같은 플래시 모드 옵션
  * FlushModeType.AUTO: 커밋이나 쿼리를 실행할 때 플러시(기본값)
  * FlushModeType.COMMIT: 커밋할 때만 플러시

## 6. 준영속

* 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없음

## 7. 정리


## References

* [자바 ORM 표준 JPA 프로그래밍](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788960777330&orderClick=LAG&Kc=)