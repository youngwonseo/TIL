# 프록시와 연관관계 관리

* 프록시, 즉시 로딩, 지연 로딩
  * 객체는 객체 그래프로 연관된 객체들을 탐색
  * 그러나 객체는 데이터베이스에 저장되어 있으므로 마음껏 탐색하기는 어려움
  * JPA는 이 문제를 프록시를 사용해서 해결
  * 처음부터 데이터베이스에서 탐색하는 것이 아니라 실제 사용하는 시점에 탐색가능
  * 그러나 자주 함께 사용되는 객체들은 조인을 통해 처음부터 함께 조회하는것이 효과적
  * JPA는 이를 즉시로딩과 지연로딩으로 지원
* 영속성 전이, 고아 객체
  * JPA는 연관된 객체를 함께 저장하거나 함께 삭제할 수 있는 영속성 전이와 고아 삭제라는 기능을 제공

## 프록시

* 프록시 객체
* JPA 표준 명세에는 지연 로딩의 구현 방법을 JPA 구현체에 위임
  * 하이버네이트는 프록시를 사용하는 방법과 바이트코드를 수정하는 두 가지 방법을 제공

* 프록시 초기화 과정
  1. 프록시 객체에 member.getName()을 호출해서 데이터를 조회
  2. 
  3. 
  4. 
  5. 

* 프록시 특징
  * 준영속(detached)상태의 프록시를 초기화 하면 lazyInitializationException 발생
  * 영속성 컨텍스트가 종료된후 초기화를 시도  

* 프록시와 식별자
  * (`@Access(AccessType.PROPERTY)`) 식별자를 호출해도 프록시를 초기화하기는 않음
  * (`@Access(AccessType.FILED)`) 식별자만 호출해도 프록시가 초기화됨
  * 연관관계를 설정하는 경우 식별자만 사용하므로 프록시를 사용하면 데이터베이스 조회없이 연관관계를 설정할 수 있음
    * 연관관계 설정시에는 엔티티 접근 방식이 필드인 경우(`@Access(AccessType.FILED)`)도 프록시를 초기화하지 않음

```java
Member member = em.find(Member.class, "member1");
Team team = em.getReference(Team.class, "team1"); // SQL 실행하지 않음
member.setTeam(team);
```

* 프록시 확인
  *  
  * 하이버네이트의 org.hibernate.Hibernate.initialize(order.getName()) 를 사용하면 프록시를 강제로 초기화

## 즉시 로딩과 지연 로딩

* JPA는 개발자가 연관된 엔티티의 조회시점을 선택할 수 있도록 두 가지 방법을 제공
  * 즉시로딩
    * 연관된 모든 엔티티를 조회
    * `@ManyToOne(fetch = FetchType.EAGER)`
  * 지연로딩
    * 엔티티를 실제 사용하는 시점에 JPA가 SQL을 호출해서 조회
    * `@ManyToOne(fetch = FetchType.LAZY)`

* 즉시 로딩
  * 대부분의 JPA 구현제는 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용
  * NULL 제약조건과 JPA 조인 전략
    * `@JoinColumn(nullable = true)` - NULL 허용(기본값), 외부 조인 사용
    * `@JoinColumn(nullable = false)` - NULL 허용하지 않음, 내부 조인 사용

* 지연 로딩
  * member.getTeam()에서 조회한 team을 프록시 객체에 넣어둠
  * 실제 사용시 데이터를 조회 (프록시 객체 초기화)
  * 조회 대상이 이미 영속성 컨텍스트에 존재하면 프록시가 아닌 실제 엔티티를 사용

```java
Member member = em.find(Member.class, "member1");
Team team = member.getTeam(); // 객체 그래프 탐색
team.getName(); // 팀 겍체 실제 사용
```

* 즉시로딩, 지연로딩 정리
  * 처음부터 모든 엔티티를 영속성 컨텍스트에 올리는 즉시로딩도 현실적이지 않고, 필요할때 쿼리를 실행하도록 지연로딩을 사용하는 것도 최적화관점에서 꼭 좋은것만은 아님
  * 대부분의 애플리케이션 로직에서 함께 사용된다면 즉시로딩이 효율적
  * 상황에 맞게 사용되어야함

## 영속성 전이: CASCADE

* 특정 엔티티를 영속상태로 만들때 연관된 엔티티도 함께 영속성 상태로 만들고싶으면 영속성 전이(transitive persistence)를 사용
* JPA에서는 CASCADE 옵션으로 영속성 전이 사용 가능
* 저장 - 부모를 영속상태로 만들때 연관된 자식도 함께 영속상태로 만듬

```java
@Entity
public class Parent {
  ...

  @OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)
  private List<Child> children = new ArrayList<Child>();
}
```

* CASCADE의 종류
  * ALL // 모두 적용
  * PERSIST // 영속
  * MERGE // 병합
  * REMOVE // 삭제
  * REFRESH // REFRESH
  * DETACH // DETACH
* 참고로 PERSIST, REMOVE는 바로 전이가 발생하지 않고 플러시를 호출할 때 전이가 발생

## 고아객체

* JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공
* 이것을 고아 객제(ORPHAN) 제거라 함
* 부모 엔티티의 컬렉션에서 자식 엔티티의 참조가 제거되면 자식 엔티티가 자동으로 삭제됨

```java
public class Parent {
  ...

  @OneToMany(mappedBy = "parent", orphanRemoval = true)
  private List<Child> children = new ArrayList<Child>();
}

parent.getChildren().remove(0);
```

* 고아객체 제거는 영속성 컨텍스트를 플러시할 때 적용됨(DELETE SQL)
* 참조가 제거된 엔티티는 다른 엔티티에서 참조하지 않는 고아 객체로 보고 삭제하는 기능, 이 때문에 자식을 참조하는 곳이 하나이야함
  * 이러한 이유로 OneToOne, OneToMany에서만 적용가능
* 부모를 삭제하면 자식도 삭제됨 - 이것은 CascaseType.REMOVE와 같음

## 영속성 전이 + 고아 객체, 생명주기

* CascadeType.ALL + orphanRemoval = true 동시에 사용시?
  * 부모 엔티티를 통해 자식 엔티티의 생명주기를 관리 가능
* 영속성 전이는 DDD의 [Aggreate Root](https://martinfowler.com/bliki/DDD_Aggregate.html) 개념을 구현할때 사용하면 편리

## References

* [자바 ORM 표준 JPA 프로그래밍](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788960777330&orderClick=LAG&Kc=)
